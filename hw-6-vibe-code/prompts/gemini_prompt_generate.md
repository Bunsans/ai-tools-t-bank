# User

Я использую cursor напиши серию из нескольких промптов для последовательного выполнения задания ниже, можно разделить на 5 частей: Написание юнит-тестов, Проведение нагрузочного тестирования, Создание документации, Рефакторинг кода, Разработка CI/CD-пайлпайна.

Промпт должен удовлетворять требованиям the-clear-framework.pdf



```
Полный цикл доработки проекта с AI
Данное задание для самопроверки является центральным в дисциплине, так как раскрывает всю мощь AI-ассистентов для разработчиков.

Не стесняйтесь попробовать выполнить его с разными моделями, а также с разными изученными ранее техниками промпт-инжиниринга.

Описание
В этом задании вы проведёте полный цикл улучшения кода проекта, используя инструменты искусственного интеллекта (ChatGPT, Copilot, Claude и т.д.).

Ваша цель — показать, что вы умеете использовать LLM для инженерных задач на всех этапах:

Написание юнит-тестов
Проведение нагрузочного тестирования
Создание документации
Рефакторинг кода
Разработка CI/CD-пайлпайна
Всё должно быть реализовано с использованием LLM/AI-ассистента.

Данные
Возьмите любой из предложенных проектов для дальнейшей доработки.

https://github.com/somnoynadno/hits-docker-practice

Что нужно сделать
Написать юнит-тесты
Сгенерируйте тесты с помощью LLM.

Запустите их и убедитесь, что они проходят.

Провести нагрузочные тесты
Сгенерируйте сценарий нагрузочного тестирования.

Выполните тесты и соберите метрики (RPS, latency, error rate).

Написать документацию
С помощью LLM создайте README или техническое описание проекта.

Опишите архитектуру, запуск и API (если есть).

Провести рефакторинг кода
С помощью LLM найдите проблемные участки в коде и улучшите их.

Сохраните функциональность проекта.

Разработать CI/CD-пайплайн
Проект должен быть контейнеризован с использованием Docker.

С помощью LLM должны быть созданы джобы для сборки, тестирования и развертывания приложения.

Рекомендуется использовать GitHub Actions или GitLab CI для реализации последней задачи.

Что сдаётся
Обновлённый (доработанный) проект в виде репозитория или zip-архива.

Файл отчета, содержащий использованные модели и промпты, а также результаты доработок и запусков тестов.
```

# Model
Ниже представлена серия промптов для среды **Cursor**, разработанная в соответствии с принципами **CLEAR Framework** (Concise, Logical, Explicit, Adaptive, Reflection).

Поскольку вы используете Cursor, я включил использование контекстных команд (например, `@Codebase`), чтобы сделать промпты максимально эффективными. Выполняйте их последовательно.

---

### Часть 1: Написание юнит-тестов

**Принцип CLEAR:**
*   **Logical:** Сначала анализ, потом генерация.
*   **Explicit:** Четкое указание фреймворка и покрытия.
*   **Reflective:** Требование проверки работоспособности.

**Промпт для Cursor:**
```markdown
@Codebase Проанализируй текущую структуру проекта и основную логику приложения. 
Напиши серию юнит-тестов, используя стандартный для этого языка тестировочный фреймворк (например, pytest для Python или testing для Go). 

Требования к ответу (Explicit):
1. Покрой тестами основные эндпоинты API и функции бизнес-логики.
2. Включи как позитивные сценарии, так и проверку граничных случаев (edge cases).
3. Код тестов должен быть готовым к запуску.
4. В конце объясни, какой командой запустить эти тесты.
```

---

### Часть 2: Проведение нагрузочного тестирования

**Принцип CLEAR:**
*   **Concise:** Краткое описание задачи.
*   **Explicit:** Указание конкретных инструментов (Locust/k6) и метрик.
*   **Adaptive:** Адаптация сценария под текущий API.

**Промпт для Cursor:**
```markdown
@Codebase Сгенерируй скрипт для нагрузочного тестирования этого приложения, используя инструмент Locust (на Python) или k6.

Сценарий (Logical):
1. Пользователь обращается к главному эндпоинту.
2. Имитация нагрузки с постепенным увеличением до 100 пользователей (RPS).

Вывод (Explicit):
- Предоставь полный код скрипта.
- Напиши команду для запуска теста.
- Объясни, как интерпретировать метрики: latency (задержка) и error rate (процент ошибок) в результатах этого скрипта.
```

---

### Часть 3: Создание документации

**Принцип CLEAR:**
*   **Logical:** Структурированный подход к документации.
*   **Reflective:** Оценка полноты информации на основе кода.
*   **Explicit:** Запрос конкретных разделов и диаграмм.

**Промпт для Cursor:**
```markdown
@Codebase Создай файл README.md для этого проекта. Документация должна быть полной и профессиональной.

Структура (Explicit):
1. **Описание:** Что делает проект.
2. **Установка и запуск:** Пошаговая инструкция (включая запуск через Docker).
3. **API Документация:** Список доступных эндпоинтов, методы и примеры запросов/ответов.
4. **Архитектура:** Сгенерируй код диаграммы в формате MermaidJS, показывающий структуру компонентов приложения.

Убедись, что инструкции соответствуют текущему коду (Reflection).
```

---

### Часть 4: Рефакторинг кода

**Принцип CLEAR:**
*   **Adaptive:** Просьба проанализировать и улучшить, а не просто переписать.
*   **Concise:** Фокус на улучшении без потери смысла.
*   **Reflective:** Оценка качества кода ("code smells").

**Промпт для Cursor:**
```markdown
@Codebase Выступи в роли Senior-разработчика. Проведи ревью кода с целью рефакторинга.

Задачи (Logical):
1. Найди участки кода, которые сложны для понимания, имеют "code smells" или неоптимизированы.
2. Предложи улучшенные версии этих участков кода.
3. Добавь комментарии (Docstrings), объясняющие сложные моменты.

Важно (Explicit): Функциональность приложения должна сохраниться полностью. Не меняй внешние интерфейсы API.
```

---

### Часть 5: Разработка CI/CD-пайплайна

**Принцип CLEAR:**
*   **Explicit:** Четкое задание этапов (Build, Test).
*   **Logical:** Последовательность действий в пайплайне.
*   **Concise:** Прямое указание на используемый инструмент (GitHub Actions).

**Промпт для Cursor:**
```markdown
@Codebase Мне нужно настроить CI/CD для этого репозитория.

1. Убедись, что в проекте есть корректный `Dockerfile`. Если нет — создай его, оптимизировав размер образа.
2. Создай файл workflow для GitHub Actions (`.github/workflows/ci.yml`).

Этапы пайплайна (Explicit):
- **Build:** Сборка Docker-образа.
- **Test:** Запуск юнит-тестов, которые мы создали ранее.
- **Lint:** Проверка стиля кода (линтер).

Пайплайн должен падать (fail), если тесты не проходят.
```

---

### Как это соответствует CLEAR Framework?

1.  **Concise (Краткость):** Промпты избегают "воды", фокусируясь на ключевых словах (Docker, Locust, Pytest, MermaidJS).
2.  **Logical (Логичность):** Каждый промпт задает структуру (Сделай А, затем Б, чтобы получить В).
3.  **Explicit (Ясность):** Четко указано, *что* должно быть на выходе (код, команда запуска, диаграмма, файл .yml).
4.  **Adaptive (Адаптивность):** Промпты используют контекст `@Codebase`, заставляя AI подстраиваться под конкретный язык программирования и структуру вашего проекта, а не выдавать шаблонный ответ.
5.  **Reflective (Рефлексия):** В промптах есть элементы проверки ("Убедись, что инструкции соответствуют", "Пайплайн должен падать, если тесты не проходят").